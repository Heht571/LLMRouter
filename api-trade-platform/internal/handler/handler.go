package handler

import (
	"api-trade-platform/internal/config"
	"api-trade-platform/internal/middleware"
	"api-trade-platform/internal/model" // Added for ErrorResponse and other models
	"api-trade-platform/internal/redis"
	"api-trade-platform/internal/store/postgres"
	"api-trade-platform/internal/utils"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	_ "api-trade-platform/docs" // docs is generated by Swag CLI
)

// BaseHandler 结构用于聚合依赖项，并作为其他具体 handler 的基础
// 这是一个临时的聚合方式，后续会根据功能拆分为更具体的 handlers
// 例如 AuthHandler, SellerAPIHandler, BuyerAPIHandler, ProxyHandler, UsageHandler
type BaseHandler struct {
	db              *postgres.Store              // 数据库访问
	cfg             *config.Config               // 应用配置
	userStore       *postgres.UserStore          // 用户存储
	apiServiceStore *postgres.APIServiceStore    // API服务存储
	platformKeyStore *postgres.PlatformKeyStore  // 平台密钥存储
	usageLogStore   *postgres.UsageLogStore      // 使用日志存储
	apiDocStore     *postgres.APIDocumentationStore // API文档存储
	userAccountStore *postgres.UserAccountStore   // 用户账户设置存储
	// Redis 服务
	redisClient     *redis.RedisClient           // Redis客户端
	sessionService  *redis.SessionService        // 会话管理服务
	cacheService    *redis.CacheService          // 缓存服务
	rateLimiter     *redis.RateLimiter           // 限流服务
}

// NewBaseHandler 创建一个新的 BaseHandler 实例
// 这是一个临时的构造函数，后续会为每个具体 handler 创建独立的构造函数
func NewBaseHandler(db *postgres.Store, cfg *config.Config, redisClient *redis.RedisClient) *BaseHandler {
	// 创建Redis服务实例（如果Redis可用）
	var sessionService *redis.SessionService
	var cacheService *redis.CacheService
	var rateLimiter *redis.RateLimiter
	
	if redisClient != nil {
		sessionService = redis.NewSessionService(redisClient)
		cacheService = redis.NewCacheService(redisClient)
		rateLimiter = redis.NewRateLimiter(redisClient)
	}
	
	return &BaseHandler{
		db:              db,
		cfg:             cfg,
		userStore:       postgres.NewUserStore(db),
		apiServiceStore: postgres.NewAPIServiceStore(db),
		platformKeyStore: postgres.NewPlatformKeyStore(db),
		usageLogStore:   postgres.NewUsageLogStore(db),
		apiDocStore:    postgres.NewAPIDocumentationStore(db.DB),
		userAccountStore: postgres.NewUserAccountStore(db),
		// Redis 服务（可能为 nil）
		redisClient:     redisClient,
		sessionService:  sessionService,
		cacheService:    cacheService,
		rateLimiter:     rateLimiter,
	}
}

// SetupRoutes 设置所有 API 路由
// 这是一个临时的路由设置函数，后续会根据 handler 拆分进行更细致的路由分组
func (h *BaseHandler) SetupRoutes(router *gin.Engine) {
	// 健康检查端点
	router.GET("/health", h.HealthCheck)

	// API V1 分组
	apiV1 := router.Group("/api/v1")
	{
		// --- 认证相关路由 (Auth Endpoints) ---
		authRoutes := apiV1.Group("/auth")
		{
			// 公开认证接口
			authRoutes.POST("/register", h.RegisterUser) // POST /api/v1/auth/register
			authRoutes.POST("/login", h.LoginUser)       // POST /api/v1/auth/login
			
			// 需要认证的账户管理接口
			authProtected := authRoutes.Group("/")
			authProtected.Use(middleware.AuthMiddleware(h.cfg.JWT_SECRET_KEY))
			{
				authProtected.GET("/profile", h.GetUserProfile)           // GET /api/v1/auth/profile
				authProtected.PUT("/profile", h.UpdateUserProfile)        // PUT /api/v1/auth/profile
				authProtected.POST("/change-password", h.ChangePassword)  // POST /api/v1/auth/change-password
				authProtected.GET("/account", h.GetUserAccount)           // GET /api/v1/auth/account
			}
		}

		// --- 卖家 API 管理路由 (Seller API Management - 需认证) ---
		sellerRoutes := apiV1.Group("/seller")
		sellerRoutes.Use(middleware.AuthMiddleware(h.cfg.JWT_SECRET_KEY))
		sellerRoutes.Use(middleware.RequireRole("seller"))
		{
			sellerRoutes.POST("/services", h.RegisterAPIService)     // POST /api/v1/seller/services
			sellerRoutes.GET("/services", h.ListSellerAPIs)        // GET /api/v1/seller/services
			sellerRoutes.PUT("/services/:service_id", h.UpdateAPIService)    // PUT /api/v1/seller/services/{service_id}
			sellerRoutes.PUT("/services/:service_id/pricing", h.UpdateAPIPricing) // PUT /api/v1/seller/services/{service_id}/pricing
			sellerRoutes.DELETE("/services/:service_id", h.DeleteAPIService) // DELETE /api/v1/seller/services/{service_id}
			sellerRoutes.GET("/usage", h.GetSellerUsage)           // GET /api/v1/seller/usage
			sellerRoutes.GET("/usage/timeseries", h.GetSellerUsageTimeSeries) // GET /api/v1/seller/usage/timeseries
			
			// 卖家专用账户设置
			sellerRoutes.GET("/account-settings", h.GetSellerAccountSettings)    // GET /api/v1/seller/account-settings
			sellerRoutes.PUT("/account-settings", h.UpdateSellerAccountSettings) // PUT /api/v1/seller/account-settings
			
			// API文档管理路由
			sellerRoutes.POST("/services/:service_id/documentation", h.CreateAPIDocumentation)     // POST /api/v1/seller/services/{service_id}/documentation
			sellerRoutes.GET("/services/:service_id/documentation", h.GetAPIDocumentation)        // GET /api/v1/seller/services/{service_id}/documentation
			sellerRoutes.PUT("/services/:service_id/documentation", h.UpdateAPIDocumentation)     // PUT /api/v1/seller/services/{service_id}/documentation
			sellerRoutes.DELETE("/services/:service_id/documentation", h.DeleteAPIDocumentation)  // DELETE /api/v1/seller/services/{service_id}/documentation
			
			// API端点文档管理路由
			sellerRoutes.POST("/services/:service_id/documentation/endpoints", h.CreateAPIEndpoint)     // POST /api/v1/seller/services/{service_id}/documentation/endpoints
			sellerRoutes.PUT("/documentation/endpoints/:endpoint_id", h.UpdateAPIEndpoint)              // PUT /api/v1/seller/documentation/endpoints/{endpoint_id}
			sellerRoutes.DELETE("/documentation/endpoints/:endpoint_id", h.DeleteAPIEndpoint)           // DELETE /api/v1/seller/documentation/endpoints/{endpoint_id}
		}

		// --- 买家 API 访问路由 (Buyer API Access - 需认证) ---
		buyerRoutes := apiV1.Group("/buyer")
		buyerRoutes.Use(middleware.AuthMiddleware(h.cfg.JWT_SECRET_KEY))
		buyerRoutes.Use(middleware.RequireRole("buyer"))
		{
			buyerRoutes.GET("/services", h.ListAvailableAPIs)                                  // GET /api/v1/buyer/services
			buyerRoutes.GET("/services/:service_id", h.GetAPIDetail)                          // GET /api/v1/buyer/services/{service_id}
			buyerRoutes.POST("/services/:service_id/subscribe", h.SubscribeToAPI)             // POST /api/v1/buyer/services/{service_id}/subscribe
			buyerRoutes.DELETE("/subscriptions/:service_id", h.UnsubscribeFromAPI)            // DELETE /api/v1/buyer/subscriptions/{service_id}
			buyerRoutes.GET("/subscriptions", h.GetBuyerSubscriptions)                        // GET /api/v1/buyer/subscriptions
			buyerRoutes.GET("/usage", h.GetBuyerUsage)                                     // GET /api/v1/buyer/usage
			buyerRoutes.GET("/usage/timeseries", h.GetBuyerUsageTimeSeries)               // GET /api/v1/buyer/usage/timeseries
			
			// 买家专用账户设置
			buyerRoutes.GET("/account-settings", h.GetBuyerAccountSettings)    // GET /api/v1/buyer/account-settings
			buyerRoutes.PUT("/account-settings", h.UpdateBuyerAccountSettings) // PUT /api/v1/buyer/account-settings
			
			// API文档查看路由
			buyerRoutes.GET("/services/:service_id/documentation", h.GetAPIDocumentation)     // GET /api/v1/buyer/services/{service_id}/documentation
		}
	}

	// --- 平台 API 代理核心路由 (Platform API Proxy Core) ---
	proxyRoutes := router.Group("/proxy/v1")
	proxyRoutes.Use(middleware.PlatformAPIKeyAuthMiddleware(h.platformKeyStore))
	{
		// 匹配所有 HTTP 方法和路径
		proxyRoutes.Any("/:service_id/*seller_path", h.ProxyToSellerService) // e.g., /proxy/v1/{service_id}/{seller_path...}
	}

	// Swaggo API 文档路由
	// 访问 /swagger/index.html 查看 API 文档
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// 默认路由，返回 404
	router.NoRoute(func(c *gin.Context) {
		c.JSON(http.StatusNotFound, gin.H{"code": "PAGE_NOT_FOUND", "message": "Page not found"})
	})
}

// HealthCheck godoc
// @Summary 服务健康检查
// @Description 检查 API 平台服务是否正常运行
// @Tags 健康检查
// @Accept json
// @Produce json
// @Success 200 {object} map[string]string "服务正常运行"
// @Router /health [get]
func (h *BaseHandler) HealthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{"status": "UP"})
}

// --- Placeholder Handlers --- (这些将在后续步骤中被具体实现替换)

// RegisterUser godoc
// @Summary 用户注册
// @Description 注册新的卖家或买家账户，支持角色选择
// @Tags 用户认证
// @Accept json
// @Produce json
// @Param user body model.UserRegistrationRequest true "用户注册信息"
// @Success 201 {object} model.UserResponse "用户创建成功"
// @Failure 400 {object} model.ErrorResponse "请求参数错误或用户名/邮箱已存在"
// @Failure 500 {object} model.ErrorResponse "服务器内部错误"
// @Router /auth/register [post]
func (h *BaseHandler) RegisterUser(c *gin.Context) {
	var req model.UserRegistrationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data: " + err.Error()})
		return
	}

	// 检查用户名是否已存在
	usernameExists, err := h.userStore.CheckUsernameExists(req.Username)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check username"})
		return
	}
	if usernameExists {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Username already exists"})
		return
	}

	// 检查邮箱是否已存在
	emailExists, err := h.userStore.CheckEmailExists(req.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check email"})
		return
	}
	if emailExists {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Email already exists"})
		return
	}

	// 哈希密码
	hashedPassword, err := utils.HashPassword(req.Password)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
		return
	}

	// 创建用户
	user := &model.User{
		Username:     req.Username,
		PasswordHash: hashedPassword,
		Email:        req.Email,
		Role:         req.Role,
	}

	err = h.userStore.CreateUser(user)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	// 返回用户信息（不包含密码）
	userResponse := model.UserResponse{
		UserID:   user.UserID,
		Username: user.Username,
		Email:    user.Email,
		Role:     user.Role,
	}

	c.JSON(http.StatusCreated, userResponse)
}

// LoginUser godoc
// @Summary 用户登录
// @Description 使用用户名和密码登录，成功返回 JWT 认证令牌
// @Tags 用户认证
// @Accept json
// @Produce json
// @Param credentials body model.UserLoginRequest true "登录凭证"
// @Success 200 {object} model.UserLoginResponse "登录成功，返回 JWT 令牌"
// @Failure 400 {object} model.ErrorResponse "请求参数错误"
// @Failure 401 {object} model.ErrorResponse "用户名或密码错误"
// @Failure 429 {object} model.ErrorResponse "登录尝试过于频繁"
// @Failure 500 {object} model.ErrorResponse "服务器内部错误"
// @Router /auth/login [post]
func (h *BaseHandler) LoginUser(c *gin.Context) {
	var req model.UserLoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data: " + err.Error()})
		return
	}

	// 检查登录限流（如果Redis可用）
	if h.rateLimiter != nil {
		// 基于用户名的登录限流 - 使用IP限流作为临时方案
		allowed, remaining, err := h.rateLimiter.CheckIPRateLimit(c.ClientIP(), redis.LoginRateLimit)
		if err != nil {
			// 限流检查失败，记录错误但继续处理
			c.Header("X-Login-RateLimit-Error", "Login rate limit check failed")
		} else if !allowed {
			c.JSON(http.StatusTooManyRequests, gin.H{
				"error":   "Too many login attempts",
				"message": "Please wait before trying again",
				"retry_after": redis.LoginRateLimit.Window.Seconds(),
			})
			return
		} else {
			// 设置限流响应头
			c.Header("X-Login-RateLimit-Remaining", strconv.FormatInt(remaining, 10))
		}
	}

	// 根据用户名获取用户
	user, err := h.userStore.GetUserByUsername(req.Username)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid username or password"})
		return
	}

	// 验证密码
	if !utils.CheckPassword(req.Password, user.PasswordHash) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid username or password"})
		return
	}

	// 生成 JWT token
	token, err := utils.GenerateJWT(user.UserID, user.Username, user.Email, user.Role, h.cfg.JWT_SECRET_KEY)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
		return
	}

	// 创建会话（如果Redis可用）
	if h.sessionService != nil {
		// 创建Redis会话
		if sessionID, err := h.sessionService.CreateSession(
			user.UserID,
			user.Username,
			user.Role,
			c.ClientIP(),
			c.GetHeader("User-Agent"),
			time.Duration(h.cfg.JWT_EXPIRATION_HOURS)*time.Hour,
		); err != nil {
			// 会话创建失败，记录错误但不影响登录
			c.Header("X-Session-Error", "Failed to create session")
		} else {
			// 会话创建成功，可以在响应头中添加会话ID
			c.Header("X-Session-ID", sessionID)
		}
	}

	// 返回登录响应
	response := model.UserLoginResponse{
		Token: token,
	}

	c.JSON(http.StatusOK, response)
}

// RegisterAPIService godoc
// @Summary 注册新的 API 服务
// @Description 卖家注册新的 API 服务，系统将生成代理前缀并加密存储原始 API 密钥
// @Tags 卖家服务管理
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param api_service body model.RegisterAPIServiceRequest true "API 服务注册信息"
// @Success 201 {object} model.APIServiceResponse "API 服务注册成功"
// @Failure 400 {object} model.ErrorResponse "请求参数错误或 URL 格式不正确"
// @Failure 401 {object} model.ErrorResponse "用户未认证或权限不足"
// @Failure 500 {object} model.ErrorResponse "服务器内部错误"
// @Router /api/v1/seller/services [post]
func (h *BaseHandler) RegisterAPIService(c *gin.Context) {
	var req model.RegisterAPIServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// 检查是否是URL格式错误
		errorStr := err.Error()
		if strings.Contains(errorStr, "url") {
			c.JSON(http.StatusBadRequest, gin.H{
				"error": "URL格式错误：请确保原始端点URL格式正确，例如：https://api.example.com 或 http://localhost:8080",
				"details": err.Error(),
			})
		} else {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data: " + err.Error()})
		}
		return
	}

	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 生成服务代理前缀
	proxyPrefix := utils.GenerateServiceProxyPrefix(req.Name)

	// 加密原始API密钥
	encryptedAPIKey, err := utils.EncryptAPIKey(req.OriginalAPIKey, h.cfg.ENCRYPTION_KEY)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to encrypt API key"})
		return
	}

	// 创建API服务
	apiService := &model.APIService{
		SellerUserID:             userID,
		Name:                     req.Name,
		Description:              req.Description,
		OriginalEndpointURL:      req.OriginalEndpointURL,
		EncryptedOriginalAPIKey:  encryptedAPIKey,
		PlatformProxyPrefix:      proxyPrefix,
		IsActive:                 true,
	}

	if err = h.apiServiceStore.CreateAPIService(apiService); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create API service"})
		return
	}

	// 返回创建的API服务信息
	response := model.APIServiceResponse{
		ServiceID:           apiService.ServiceID,
		Name:                apiService.Name,
		Description:         apiService.Description,
		PlatformProxyPrefix: apiService.PlatformProxyPrefix,
		IsActive:            apiService.IsActive,
	}

	c.JSON(http.StatusCreated, response)
}

// ListSellerAPIs godoc
// @Summary 获取卖家的 API 服务列表
// @Description 获取当前认证卖家注册的所有 API 服务，包括服务状态和代理信息
// @Tags 卖家服务管理
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {array} model.APIServiceResponse "成功获取 API 服务列表"
// @Failure 401 {object} model.ErrorResponse "用户未认证或权限不足"
// @Failure 500 {object} model.ErrorResponse "服务器内部错误"
// @Router /api/v1/seller/services [get]
func (h *BaseHandler) ListSellerAPIs(c *gin.Context) {
	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取卖家的API服务列表
	apiServices, err := h.apiServiceStore.GetAPIServicesBySellerID(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API services"})
		return
	}

	// 检查是否有API服务
	if len(apiServices) == 0 {
		c.JSON(http.StatusOK, gin.H{
			"apis": []model.APIServiceResponse{},
			"message": "当前无注册API",
		})
		return
	}

	// 转换为响应格式
	var responses []model.APIServiceResponse
	for _, service := range apiServices {
		response := model.APIServiceResponse{
			ServiceID:           service.ServiceID,
			Name:                service.Name,
			Description:         service.Description,
			PlatformProxyPrefix: service.PlatformProxyPrefix,
			IsActive:            service.IsActive,
			PricingModel:        service.PricingModel,
			PricePerCall:        service.PricePerCall,
			PricePerToken:       service.PricePerToken,
		}
		responses = append(responses, response)
	}

	c.JSON(http.StatusOK, gin.H{"apis": responses})
}

// ListAvailableAPIs godoc
// @Summary 获取平台可用的 API 服务列表
// @Description 列出平台上所有卖家注册并激活的 API 服务，供买家浏览。
// @Tags Buyer
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {array} object{service_id=int,name=string,description=string,seller_username=string} "成功获取可用 API 列表 (Successfully retrieved available API list)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /buyer/services [get]
func (h *BaseHandler) ListAvailableAPIs(c *gin.Context) {
	// 获取所有活跃的API服务
	apiServices, err := h.apiServiceStore.GetAllActiveAPIServices()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get available APIs"})
		return
	}

	// 转换为响应格式
	var responses []model.APIServiceResponse
	for _, service := range apiServices {
		// 解析特性字符串为数组
		var features []string
		if service.Features != "" {
			// 尝试解析JSON，如果失败则使用默认值
			if err := json.Unmarshal([]byte(service.Features), &features); err != nil {
				features = []string{"API服务"} // 默认特性
			}
		}

		// 获取卖家用户名
		sellerUsername := "未知卖家"
		if seller, err := h.userStore.GetUserByID(service.SellerUserID); err == nil && seller != nil {
			sellerUsername = seller.Username
		}

		response := model.APIServiceResponse{
			ServiceID:           service.ServiceID,
			Name:                service.Name,
			Description:         service.Description,
			PlatformProxyPrefix: service.PlatformProxyPrefix,
			IsActive:            service.IsActive,
			SellerUsername:      sellerUsername,
			Category:            service.Category,
			Rating:              service.Rating,
			ReviewCount:         service.ReviewCount,
			PricePerCall:        service.PricePerCall,
			PricingModel:        service.PricingModel,
			PricePerToken:       service.PricePerToken,
			TotalCalls:          service.TotalCalls,
			SubscriberCount:     service.SubscriberCount,
			Features:            features,
			Documentation:       service.Documentation,
		}
		responses = append(responses, response)
	}

	c.JSON(http.StatusOK, gin.H{"apis": responses})
}

// GetAPIDetail godoc
// @Summary 获取 API 服务详细信息
// @Description 获取指定 API 服务的详细信息，包括文档、订阅状态等
// @Tags Buyer
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param service_id path int true "API 服务 ID (API Service ID)"
// @Success 200 {object} model.APIServiceDetailResponse "API 详情信息"
// @Failure 400 {object} object{error=string} "请求参数错误 (Invalid input)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 404 {object} object{error=string} "API 服务不存在 (API service not found)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /buyer/services/{service_id} [get]
func (h *BaseHandler) GetAPIDetail(c *gin.Context) {
	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取服务ID
	serviceIDStr := c.Param("service_id")
	serviceIDInt, err := strconv.Atoi(serviceIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}
	serviceID := int64(serviceIDInt)

	// 获取API服务信息
	apiService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}

	// 检查用户是否已订阅
	isSubscribed, err := h.platformKeyStore.CheckSubscriptionExists(userID, serviceID)
	if err != nil {
		isSubscribed = false
	}

	// 解析特性字符串为数组
	var features []string
	if apiService.Features != "" {
		// 尝试解析JSON，如果失败则使用默认值
		if err := json.Unmarshal([]byte(apiService.Features), &features); err != nil {
			features = []string{"API服务"} // 默认特性
		}
	}

	// 获取卖家用户名
	sellerUsername := "未知卖家"
	if seller, err := h.userStore.GetUserByID(apiService.SellerUserID); err == nil && seller != nil {
		sellerUsername = seller.Username
	}

	// 构建响应
	response := model.APIServiceDetailResponse{
		APIServiceResponse: model.APIServiceResponse{
			ServiceID:           apiService.ServiceID,
			Name:                apiService.Name,
			Description:         apiService.Description,
			PlatformProxyPrefix: apiService.PlatformProxyPrefix,
			IsActive:            apiService.IsActive,
			SellerUsername:      sellerUsername,
			Category:            apiService.Category,
			Rating:              apiService.Rating,
			ReviewCount:         apiService.ReviewCount,
			PricePerCall:        apiService.PricePerCall,
			PricingModel:        apiService.PricingModel,
			PricePerToken:       apiService.PricePerToken,
			TotalCalls:          apiService.TotalCalls,
			SubscriberCount:     apiService.SubscriberCount,
			Features:            features,
			Documentation:       apiService.Documentation,
		},
		IsSubscribed: isSubscribed,
	}

	// 如果已订阅，可以在这里添加订阅信息
	// 注意：需要额外查询获取订阅详情
	if isSubscribed {
		// TODO: 如果需要显示订阅详情，需要额外查询
		// response.SubscriptionDate = &subscriptionDetails.CreatedAt
		// response.PlatformAPIKey = subscriptionDetails.PlatformAPIKey
	}

	c.JSON(http.StatusOK, response)
}

// SubscribeToAPI godoc
// @Summary 订阅 API 服务
// @Description 买家选择一个 API 服务进行订阅，平台将为此生成一个唯一的 API 密钥和代理 URL。
// @Tags Buyer
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param service_id path int true "API 服务 ID (API Service ID)"
// @Success 200 {object} object{platform_api_key=string,platform_proxy_url=string} "订阅成功，返回平台密钥和代理 URL (Subscription successful, returns platform key and proxy URL)"
// @Failure 400 {object} object{error=string} "请求参数错误 (Invalid input - e.g., service_id not found)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 409 {object} object{error=string} "已订阅该服务 (Already subscribed to this service)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /buyer/services/{service_id}/subscribe [post]
func (h *BaseHandler) SubscribeToAPI(c *gin.Context) {
	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取服务ID
	serviceIDStr := c.Param("service_id")
	serviceIDInt, err := strconv.Atoi(serviceIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}
	serviceID := int64(serviceIDInt)
	
	// 添加调试日志
	fmt.Printf("[DEBUG] SubscribeToAPI: userID=%d, serviceID=%d\n", userID, serviceID)
	
	// 检查API服务是否存在
	apiService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		fmt.Printf("[DEBUG] API service not found: %v\n", err)
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}

	// 检查是否已经订阅
	alreadySubscribed, err := h.platformKeyStore.CheckSubscriptionExists(userID, serviceID)
	if err != nil {
		fmt.Printf("[DEBUG] Failed to check subscription: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check subscription"})
		return
	}
	if alreadySubscribed {
		fmt.Printf("[DEBUG] Already subscribed: userID=%d, serviceID=%d\n", userID, serviceID)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Already subscribed to this API"})
		return
	}

	// 生成平台API密钥
	platformAPIKey := utils.GeneratePlatformAPIKey()

	// 加密API密钥
	encryptedKey, err := utils.EncryptAPIKey(platformAPIKey, h.cfg.ENCRYPTION_KEY)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to encrypt API key"})
		return
	}

	// 创建平台API密钥记录
	platformKey := &model.PlatformAPIKey{
		BuyerUserID:    userID,
		ServiceID:      serviceID,
		PlatformAPIKey: encryptedKey,
		IsActive:       true,
	}

	err = h.platformKeyStore.CreatePlatformAPIKey(platformKey)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create subscription"})
		return
	}

	// 返回订阅信息
	response := model.SubscribeToAPIResponse{
		PlatformAPIKey:   platformAPIKey, // 返回未加密的密钥给用户
		PlatformProxyURL: apiService.PlatformProxyPrefix,
	}

	c.JSON(http.StatusCreated, response)
}

// GetBuyerSubscriptions godoc
// @Summary 获取买家订阅列表
// @Description 获取买家已订阅的API服务列表，包括订阅详情和API密钥信息。
// @Tags Buyer
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Success 200 {object} object{apis=[]object} "订阅列表 (Subscription list)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /buyer/subscriptions [get]
func (h *BaseHandler) GetBuyerSubscriptions(c *gin.Context) {
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取买家的所有活跃订阅
	subscriptions, err := h.platformKeyStore.GetPlatformAPIKeysByBuyerID(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get subscriptions"})
		return
	}

	// 构建响应数据
	var apis []gin.H
	for _, subscription := range subscriptions {
		// 获取对应的API服务信息
		apiService, err := h.apiServiceStore.GetAPIServiceByID(subscription.ServiceID)
		if err != nil {
			continue // 跳过无法获取的服务
		}

		// 获取卖家用户名
		seller, err := h.userStore.GetUserByID(apiService.SellerUserID)
		sellerUsername := "Unknown"
		if err == nil {
			sellerUsername = seller.Username
		}

		api := gin.H{
			"service_id":                subscription.ServiceID,
			"name":                      apiService.Name,
			"description":               apiService.Description,
			"platform_proxy_prefix":     apiService.PlatformProxyPrefix,
			"is_active":                 apiService.IsActive && subscription.IsActive,
			"seller_username":           sellerUsername,
			"platform_api_key":          subscription.PlatformAPIKey,
			"subscription_date":         subscription.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
			"expires_at":                nil,
			"price_per_call":            apiService.PricePerCall,
			"pricing_model":             apiService.PricingModel,
			"price_per_token":           apiService.PricePerToken,
		}

		// 如果有过期时间，添加到响应中
		if subscription.ExpiresAt != nil {
			api["expires_at"] = subscription.ExpiresAt.Format("2006-01-02T15:04:05Z07:00")
		}

		apis = append(apis, api)
	}

	c.JSON(http.StatusOK, gin.H{"apis": apis})
}

// GetBuyerUsage godoc
// @Summary 查看 API 使用情况和费用
// @Description 买家查看自己在特定时间段内的 API 调用次数和指示性费用。
// @Tags Buyer
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param period query string false "查询周期 (Query period) (e.g., 'monthly', 'daily') default: 'monthly'"
// @Success 200 {object} object{calls_made=int,indicative_cost=float64,usage_details_by_api=array} "成功获取使用情况 (Successfully retrieved usage summary)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /buyer/usage [get]
func (h *BaseHandler) GetBuyerUsage(c *gin.Context) {
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取查询参数
	period := c.DefaultQuery("period", "monthly")
	includeDetails := c.DefaultQuery("include_details", "false") == "true"

	// 获取使用统计
	usageStats, err := h.usageLogStore.GetUsageStatsByBuyerID(userID, period)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get usage stats"})
		return
	}

	// 如果需要详细信息，获取使用日志
	if includeDetails {
		limit := 100 // 默认限制
		offset := 0
		usageLogs, err := h.usageLogStore.GetUsageLogsByBuyerID(userID, limit, offset)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get usage logs"})
			return
		}
		// 构建包含详细日志的响应
		response := gin.H{
			"usage_summary": usageStats,
			"usage_logs":    usageLogs,
		}
		c.JSON(http.StatusOK, response)
	} else {
		// 直接返回使用统计数据
		c.JSON(http.StatusOK, usageStats)
	}
}

// GetBuyerUsageTimeSeries godoc
// @Summary 获取买家使用时间序列数据
// @Description 获取买家的API使用时间序列统计数据，支持按日、周、月分组。
// @Tags Buyer
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param period query string false "查询周期 (Query period) (e.g., 'daily', 'weekly', 'monthly') default: 'daily'"
// @Success 200 {object} object{period=string,data_points=array} "成功获取时间序列数据 (Successfully retrieved time series data)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /buyer/usage/timeseries [get]
func (h *BaseHandler) GetBuyerUsageTimeSeries(c *gin.Context) {
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取查询参数
	period := c.DefaultQuery("period", "daily")

	// 获取时间序列使用统计
	timeSeries, err := h.usageLogStore.GetUsageTimeSeriesByBuyerID(userID, period)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get usage time series"})
		return
	}

	c.JSON(http.StatusOK, timeSeries)
}

// GetSellerUsageTimeSeries godoc
// @Summary 获取卖家使用时间序列数据
// @Description 获取卖家的API使用时间序列统计数据，支持按日、周、月分组。
// @Tags Seller
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param period query string false "查询周期 (Query period) (e.g., 'daily', 'weekly', 'monthly') default: 'daily'"
// @Success 200 {object} object{period=string,data_points=array} "成功获取时间序列数据 (Successfully retrieved time series data)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /seller/usage/timeseries [get]
func (h *BaseHandler) GetSellerUsageTimeSeries(c *gin.Context) {
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取查询参数
	period := c.DefaultQuery("period", "daily")

	// 获取时间序列使用统计
	timeSeries, err := h.usageLogStore.GetUsageTimeSeriesBySellerID(userID, period)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get usage time series"})
		return
	}

	c.JSON(http.StatusOK, timeSeries)
}

// UnsubscribeFromAPI godoc
// @Summary 取消订阅 API 服务
// @Description 买家取消对指定 API 服务的订阅，删除相关的平台密钥。
// @Tags Buyer
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param service_id path int true "API 服务 ID (API Service ID)"
// @Success 200 {object} object{message=string} "取消订阅成功 (Unsubscription successful)"
// @Failure 400 {object} object{error=string} "请求参数错误 (Invalid input - e.g., service_id not found)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 404 {object} object{error=string} "未找到订阅 (Subscription not found)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /buyer/subscriptions/{service_id} [delete]
func (h *BaseHandler) UnsubscribeFromAPI(c *gin.Context) {
	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取服务ID
	serviceIDStr := c.Param("service_id")
	serviceIDInt, err := strconv.Atoi(serviceIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}
	serviceID := int64(serviceIDInt)

	// 添加调试日志
	fmt.Printf("[DEBUG] UnsubscribeFromAPI: userID=%d, serviceID=%d\n", userID, serviceID)

	// 检查订阅是否存在
	subscriptionExists, err := h.platformKeyStore.CheckSubscriptionExists(userID, serviceID)
	if err != nil {
		fmt.Printf("[DEBUG] Failed to check subscription: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check subscription"})
		return
	}
	if !subscriptionExists {
		fmt.Printf("[DEBUG] Subscription not found: userID=%d, serviceID=%d\n", userID, serviceID)
		c.JSON(http.StatusNotFound, gin.H{"error": "Subscription not found"})
		return
	}

	// 删除平台API密钥记录（取消订阅）
	err = h.platformKeyStore.DeletePlatformAPIKey(userID, serviceID)
	if err != nil {
		fmt.Printf("[DEBUG] Failed to delete subscription: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to unsubscribe"})
		return
	}

	fmt.Printf("[DEBUG] Successfully unsubscribed: userID=%d, serviceID=%d\n", userID, serviceID)

	// 返回成功响应
	c.JSON(http.StatusOK, gin.H{"message": "Successfully unsubscribed from API"})
}

// @Summary Proxy API request to seller's service
// @Description Proxies an incoming API request to the registered seller's API service, handling authentication and usage tracking.
// @Tags Platform API Proxy
// @Accept json
// @Produce json
// @Param platform_api_key header string true "Platform API Key issued to the buyer"
// @Param proxiedPath path string true "Path to be proxied to the seller's service"
// @Router /proxy/{proxiedPath} [POST] // Note: Handles ANY HTTP method via Gin's Any() method
// @Success 200 {object} map[string]interface{} "Proxied response from seller's service"
// @Failure 400 {object} model.ErrorResponse "Bad Request (e.g., missing or invalid platform API key)"
// @Failure 401 {object} model.ErrorResponse "Unauthorized (e.g., invalid or revoked platform API key)"
// @Failure 403 {object} model.ErrorResponse "Forbidden (e.g., API key not authorized for this service or quota exceeded)"
// @Failure 404 {object} model.ErrorResponse "Not Found (e.g., seller service endpoint not found)"
// @Failure 500 {object} model.ErrorResponse "Internal Server Error (e.g., platform error or error from seller's service)"
// @Failure 502 {object} model.ErrorResponse "Bad Gateway (e.g., error connecting to seller's service)"
// @Security ApiKeyAuth
func (h *BaseHandler) ProxyToSellerService(c *gin.Context) {
	// 从平台认证中间件获取信息
	platformKey, _ := middleware.GetPlatformKeyFromContext(c)
	apiService, _ := middleware.GetAPIServiceFromContext(c)
	buyerUserID, _ := middleware.GetBuyerUserIDFromContext(c)
	serviceID, _ := middleware.GetServiceIDFromContext(c)

	if platformKey == nil || apiService == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid platform API key"})
		return
	}

	// 获取卖家路径
	sellerPath := c.Param("seller_path")
	if sellerPath == "" {
		sellerPath = "/"
	}

	// 构建目标URL - 智能路径合并避免重复路径段
	baseURL, err := url.Parse(apiService.OriginalEndpointURL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid original endpoint URL"})
		return
	}
	
	// 智能合并路径，避免重复路径段
	mergedPath := smartPathJoin(baseURL.Path, sellerPath)
	baseURL.Path = mergedPath
	
	// 添加查询参数
	if c.Request.URL.RawQuery != "" {
		baseURL.RawQuery = c.Request.URL.RawQuery
	}
	
	targetURL := baseURL.String()

	// 创建HTTP客户端
	client := &http.Client{
		Timeout: 10 * time.Minute,
	}

	// 读取请求体用于token分析
	var requestBody []byte
	if c.Request.Body != nil {
		requestBody, _ = io.ReadAll(c.Request.Body)
		// 重新设置请求体供后续使用
		c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
	}

	// 创建请求
	req, err := http.NewRequest(c.Request.Method, targetURL, bytes.NewBuffer(requestBody))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create request"})
		return
	}

	// 解密卖家的原始API密钥
	originalAPIKey, err := utils.DecryptAPIKey(apiService.EncryptedOriginalAPIKey, h.cfg.ENCRYPTION_KEY)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to decrypt seller API key"})
		return
	}

	// 复制请求头（排除一些不需要的头）
	for key, values := range c.Request.Header {
		if key != "Authorization" && key != "Host" && key != "X-API-Key" {
			for _, value := range values {
				req.Header.Add(key, value)
			}
		}
	}

	// 添加卖家的原始API密钥到请求头
	// 这里假设卖家API使用Authorization Bearer token或X-API-Key头
	// 根据实际情况可能需要调整
	if originalAPIKey != "" {
		// 尝试检测API密钥的格式
		if len(originalAPIKey) > 7 && originalAPIKey[:7] == "Bearer " {
			// 如果已经包含Bearer前缀
			req.Header.Set("Authorization", originalAPIKey)
		} else if len(originalAPIKey) > 4 && (originalAPIKey[:4] == "sk-" || originalAPIKey[:4] == "pk-") {
			// 看起来像API密钥格式，使用Bearer
			req.Header.Set("Authorization", "Bearer "+originalAPIKey)
		} else {
			// 默认使用X-API-Key头
			req.Header.Set("X-API-Key", originalAPIKey)
		}
	}

	// 记录请求开始时间
	startTime := time.Now()

	// 发送请求
	resp, err := client.Do(req)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to proxy request"})
		return
	}
	defer resp.Body.Close()

	// 计算响应时间
	responseTime := time.Since(startTime)

	// 读取响应体
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": "Failed to read response"})
		return
	}

	// 解析token使用情况
	tokenParser := utils.NewTokenParser()
	modelName := tokenParser.ExtractModelName(requestBody, body)
	tokenUsage, tokenErr := tokenParser.ParseTokenUsage(body, modelName)

	// 记录使用日志
	usageLog := &model.UsageLog{
		BuyerUserID:        buyerUserID,
		APIServiceID:       serviceID,
		PlatformAPIKeyID:   platformKey.KeyID,
		SellerUserID:       apiService.SellerUserID,
		RequestPath:        sellerPath,
		RequestMethod:      c.Request.Method,
		ResponseStatusCode: resp.StatusCode,
		ProcessingTimeMs:   int(responseTime.Milliseconds()),
		IsSuccess:          resp.StatusCode >= 200 && resp.StatusCode < 300,
		RequestTimestamp:   startTime,
		RequestSizeBytes:   len(requestBody),
		ResponseSizeBytes:  len(body),
	}

	// 如果成功解析token使用情况，添加到日志中
	if tokenErr == nil && tokenUsage != nil {
		usageLog.InputTokens = tokenUsage.InputTokens
		usageLog.OutputTokens = tokenUsage.OutputTokens
		usageLog.TotalTokens = tokenUsage.TotalTokens
		usageLog.ModelName = tokenUsage.ModelName
		
		// 根据API服务的定价模式计算费用
		if apiService.PricingModel == "per_token" {
			// 按token计费：使用API服务设定的每token价格
			usageLog.Cost = float64(tokenUsage.TotalTokens) * apiService.PricePerToken
		} else {
			// 按次计费：使用API服务设定的每次调用价格
			usageLog.Cost = apiService.PricePerCall
		}
	}

	// 异步记录使用日志（不阻塞响应）
	go func() {
		if err := h.usageLogStore.CreateUsageLog(usageLog); err != nil {
			// 记录日志错误，但不影响主流程
			fmt.Printf("Failed to log usage: %v\n", err)
		}
	}()

	// 复制响应头
	for key, values := range resp.Header {
		for _, value := range values {
			c.Header(key, value)
		}
	}

	// 设置状态码并返回响应体
	c.Status(resp.StatusCode)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), body)
}

// GetSellerUsage godoc
// @Summary Get seller usage statistics
// @Description Get usage statistics for seller's API services
// @Tags Seller
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param period query string false "Time period (daily, weekly, monthly)" default("daily")
// @Success 200 {object} model.UsageSummaryResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/usage [get]
func (h *BaseHandler) GetSellerUsage(c *gin.Context) {
	// 从JWT中获取用户信息
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	sellerUserID := userID.(int64)
	period := c.DefaultQuery("period", "daily")

	// 获取卖家的使用统计
	usageStats, err := h.usageLogStore.GetUsageStatsBySellerID(sellerUserID, period)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get usage stats"})
		return
	}

	// 直接返回使用统计数据
	c.JSON(http.StatusOK, usageStats)
}

// UpdateAPIService godoc
// @Summary 卖家更新 API 服务 (Seller updates an API service)
// @Description 卖家更新自己注册的 API 服务信息。
// @Tags Seller
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param service_id path int true "API 服务 ID (API Service ID)"
// @Param service body object{name=string,description=string,original_endpoint_url=string,original_api_key=string,is_active=bool} true "更新的 API 服务信息 (Updated API service information)"
// @Success 200 {object} object{service_id=int,name=string,description=string,platform_proxy_prefix=string,is_active=bool} "更新成功 (Update successful)"
// @Failure 400 {object} object{error=string} "请求参数错误 (Invalid input)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 404 {object} object{error=string} "API 服务未找到 (API service not found)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /api/v1/seller/services/{service_id} [put]
func (h *BaseHandler) UpdateAPIService(c *gin.Context) {
	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取服务ID
	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 解析请求体
	var req model.UpdateAPIServiceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data: " + err.Error()})
		return
	}

	// 获取现有的API服务
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}

	// 检查服务是否属于当前用户
	if existingService.SellerUserID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
		return
	}

	// 准备更新的服务信息
	updatedService := &model.APIService{
		SellerUserID:             userID,
		Name:                     req.Name,
		Description:              req.Description,
		OriginalEndpointURL:      req.OriginalEndpointURL,
		EncryptedOriginalAPIKey:  existingService.EncryptedOriginalAPIKey, // 默认保持原有密钥
		PlatformProxyPrefix:      existingService.PlatformProxyPrefix,      // 保持不变
		IsActive:                 existingService.IsActive,                 // 默认保持原有状态
		Documentation:            req.Documentation,                        // 更新文档内容
	}

	// 如果提供了新的API密钥，则加密并更新
	if req.OriginalAPIKey != "" {
		encryptedAPIKey, err := utils.EncryptAPIKey(req.OriginalAPIKey, h.cfg.ENCRYPTION_KEY)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to encrypt API key"})
			return
		}
		updatedService.EncryptedOriginalAPIKey = encryptedAPIKey
	}

	// 如果提供了is_active状态，则更新
	if req.IsActive != nil {
		updatedService.IsActive = *req.IsActive
	}

	// 更新API服务
	if err = h.apiServiceStore.UpdateAPIService(serviceID, updatedService); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update API service"})
		return
	}

	// 返回更新后的API服务信息
	response := model.APIServiceResponse{
		ServiceID:           serviceID,
		Name:                updatedService.Name,
		Description:         updatedService.Description,
		PlatformProxyPrefix: updatedService.PlatformProxyPrefix,
		IsActive:            updatedService.IsActive,
	}

	c.JSON(http.StatusOK, response)
}

// UpdateAPIPricing godoc
// @Summary 卖家更新 API 定价设置 (Seller updates API pricing settings)
// @Description 卖家更新自己注册的 API 服务的定价模式和价格
// @Tags Seller
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param service_id path int true "API 服务 ID (API Service ID)"
// @Param request body model.UpdateAPIPricingRequest true "定价更新请求 (Pricing update request)"
// @Success 200 {object} object{message=string} "更新成功 (Update successful)"
// @Failure 400 {object} object{error=string} "请求参数错误 (Invalid input)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 403 {object} object{error=string} "禁止操作 (Forbidden)"
// @Failure 404 {object} object{error=string} "API 服务未找到 (API service not found)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /api/v1/seller/services/{service_id}/pricing [put]
func (h *BaseHandler) UpdateAPIPricing(c *gin.Context) {
	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取服务ID
	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 解析请求体
	var req model.UpdateAPIPricingRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data: " + err.Error()})
		return
	}

	// 验证定价模式
	if req.PricingModel != "per_call" && req.PricingModel != "per_token" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid pricing model. Must be 'per_call' or 'per_token'"})
		return
	}

	// 验证价格值
	if req.PricePerCall < 0 || req.PricePerToken < 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Prices cannot be negative"})
		return
	}

	// 检查API服务是否存在且属于当前用户
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}

	if existingService.SellerUserID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
		return
	}

	// 更新API定价
	err = h.apiServiceStore.UpdateAPIPricing(serviceID, userID, req.PricingModel, req.PricePerCall, req.PricePerToken)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update API pricing"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "API pricing updated successfully"})
}

// DeleteAPIService godoc
// @Summary 卖家删除 API 服务 (Seller deletes an API service)
// @Description 卖家删除自己注册的 API 服务。注意：如果有买家正在使用该服务，则无法删除。
// @Tags Seller
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param service_id path int true "API 服务 ID (API Service ID)"
// @Success 200 {object} object{message=string} "删除成功 (Delete successful)"
// @Failure 400 {object} object{error=string} "请求参数错误 (Invalid input)"
// @Failure 401 {object} object{error=string} "未授权 (Unauthorized)"
// @Failure 403 {object} object{error=string} "禁止操作 (Forbidden - service has active subscriptions)"
// @Failure 404 {object} object{error=string} "API 服务未找到 (API service not found)"
// @Failure 500 {object} object{error=string} "服务器内部错误 (Internal server error)"
// @Router /api/v1/seller/services/{service_id} [delete]
func (h *BaseHandler) DeleteAPIService(c *gin.Context) {
	// 从认证中间件获取用户信息
	userID, exists := middleware.GetUserIDFromContext(c)
	if !exists || userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	// 获取服务ID
	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 检查API服务是否存在且属于当前用户
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}

	if existingService.SellerUserID != userID {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
		return
	}

	// 删除API服务
	if err = h.apiServiceStore.DeleteAPIService(serviceID, userID); err != nil {
		if err.Error() == "cannot delete API service: there are active subscriptions" {
			c.JSON(http.StatusForbidden, gin.H{"error": "Cannot delete API service: there are active subscriptions"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete API service"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "API service deleted successfully"})
}

// --- API文档管理处理函数 ---

// CreateAPIDocumentation 创建API文档
// @Summary 创建API文档
// @Description 为指定的API服务创建文档
// @Tags Seller
// @Accept json
// @Produce json
// @Param service_id path int true "API服务ID"
// @Param request body model.CreateAPIDocumentationRequest true "创建API文档请求"
// @Success 201 {object} model.APIDocumentation
// @Failure 400 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 404 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/services/{service_id}/documentation [post]
func (h *BaseHandler) CreateAPIDocumentation(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 验证API服务是否存在且属于当前用户
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API service"})
		return
	}
	if existingService == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}
	if existingService.SellerUserID != userID.(int64) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
		return
	}

	// 检查是否已存在文档
	existingDoc, err := h.apiDocStore.GetAPIDocumentationByServiceID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check existing documentation"})
		return
	}
	if existingDoc != nil {
		c.JSON(http.StatusConflict, gin.H{"error": "API documentation already exists for this service"})
		return
	}

	var req model.CreateAPIDocumentationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// 提供更详细的错误信息
		errorMsg := "请求参数验证失败："
		if strings.Contains(err.Error(), "title") {
			errorMsg += "标题不能为空且长度不能超过255个字符；"
		}
		if strings.Contains(err.Error(), "content") {
			errorMsg += "内容不能为空；"
		}
		c.JSON(http.StatusBadRequest, gin.H{
			"error": errorMsg,
			"details": err.Error(),
		})
		return
	}

	doc, err := h.apiDocStore.CreateAPIDocumentation(serviceID, &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create API documentation"})
		return
	}

	c.JSON(http.StatusCreated, doc)
}

// GetAPIDocumentation 获取API文档
// @Summary 获取API文档
// @Description 获取指定API服务的文档
// @Tags Seller,Buyer
// @Produce json
// @Param service_id path int true "API服务ID"
// @Success 200 {object} model.APIDocumentationResponse
// @Failure 400 {object} model.ErrorResponse
// @Failure 404 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/services/{service_id}/documentation [get]
// @Router /api/v1/buyer/services/{service_id}/documentation [get]
func (h *BaseHandler) GetAPIDocumentation(c *gin.Context) {
	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 验证API服务是否存在
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API service"})
		return
	}
	if existingService == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}

	// 对于卖家，验证服务所有权
	userID, exists := c.Get("user_id")
	userRole, roleExists := c.Get("role")
	if exists && roleExists && userRole.(string) == "seller" {
		if existingService.SellerUserID != userID.(int64) {
			c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
			return
		}
	}

	// 对于买家，只能查看已发布的文档
	docResponse, err := h.apiDocStore.GetAPIDocumentationWithEndpoints(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API documentation"})
		return
	}
	if docResponse == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API documentation not found"})
		return
	}

	// 买家只能查看已发布的文档
	if exists && roleExists && userRole.(string) == "buyer" && !docResponse.IsPublished {
		c.JSON(http.StatusNotFound, gin.H{"error": "API documentation not found"})
		return
	}

	c.JSON(http.StatusOK, docResponse)
}

// UpdateAPIDocumentation 更新API文档
// @Summary 更新API文档
// @Description 更新指定API服务的文档
// @Tags Seller
// @Accept json
// @Produce json
// @Param service_id path int true "API服务ID"
// @Param request body model.UpdateAPIDocumentationRequest true "更新API文档请求"
// @Success 200 {object} model.APIDocumentation
// @Failure 400 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 404 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/services/{service_id}/documentation [put]
func (h *BaseHandler) UpdateAPIDocumentation(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 验证API服务是否存在且属于当前用户
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API service"})
		return
	}
	if existingService == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}
	if existingService.SellerUserID != userID.(int64) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
		return
	}

	// 获取现有文档
	existingDoc, err := h.apiDocStore.GetAPIDocumentationByServiceID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get existing documentation"})
		return
	}
	if existingDoc == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API documentation not found"})
		return
	}

	var req model.UpdateAPIDocumentationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// 提供更详细的错误信息
		errorMsg := "请求参数验证失败："
		if strings.Contains(err.Error(), "title") {
			errorMsg += "标题不能为空且长度不能超过255个字符；"
		}
		if strings.Contains(err.Error(), "content") {
			errorMsg += "内容不能为空；"
		}
		if strings.Contains(err.Error(), "required") {
			errorMsg += "缺少必填字段；"
		}
		
		c.JSON(http.StatusBadRequest, gin.H{
			"error": errorMsg,
			"details": err.Error(),
		})
		return
	}

	doc, err := h.apiDocStore.UpdateAPIDocumentation(existingDoc.DocID, &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update API documentation"})
		return
	}

	c.JSON(http.StatusOK, doc)
}

// DeleteAPIDocumentation 删除API文档
// @Summary 删除API文档
// @Description 删除指定API服务的文档
// @Tags Seller
// @Param service_id path int true "API服务ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 404 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/services/{service_id}/documentation [delete]
func (h *BaseHandler) DeleteAPIDocumentation(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 验证API服务是否存在且属于当前用户
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API service"})
		return
	}
	if existingService == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}
	if existingService.SellerUserID != userID.(int64) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
		return
	}

	// 获取现有文档
	existingDoc, err := h.apiDocStore.GetAPIDocumentationByServiceID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get existing documentation"})
		return
	}
	if existingDoc == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API documentation not found"})
		return
	}

	if err := h.apiDocStore.DeleteAPIDocumentation(existingDoc.DocID); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete API documentation"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "API documentation deleted successfully"})
}

// CreateAPIEndpoint 创建API端点文档
// @Summary 创建API端点文档
// @Description 为指定的API文档创建端点文档
// @Tags Seller
// @Accept json
// @Produce json
// @Param service_id path int true "API服务ID"
// @Param request body model.CreateAPIEndpointRequest true "创建API端点请求"
// @Success 201 {object} model.APIEndpoint
// @Failure 400 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 404 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/services/{service_id}/documentation/endpoints [post]
func (h *BaseHandler) CreateAPIEndpoint(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	serviceIDStr := c.Param("service_id")
	serviceID, err := strconv.ParseInt(serviceIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid service ID"})
		return
	}

	// 验证API服务是否存在且属于当前用户
	existingService, err := h.apiServiceStore.GetAPIServiceByID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API service"})
		return
	}
	if existingService == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API service not found"})
		return
	}
	if existingService.SellerUserID != userID.(int64) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied: service not owned by user"})
		return
	}

	// 获取API文档
	existingDoc, err := h.apiDocStore.GetAPIDocumentationByServiceID(serviceID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get API documentation"})
		return
	}
	if existingDoc == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "API documentation not found. Please create documentation first."})
		return
	}

	var req model.CreateAPIEndpointRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	endpoint, err := h.apiDocStore.CreateAPIEndpoint(existingDoc.DocID, &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create API endpoint"})
		return
	}

	c.JSON(http.StatusCreated, endpoint)
}

// UpdateAPIEndpoint 更新API端点文档
// @Summary 更新API端点文档
// @Description 更新指定的API端点文档
// @Tags Seller
// @Accept json
// @Produce json
// @Param endpoint_id path int true "端点ID"
// @Param request body model.UpdateAPIEndpointRequest true "更新API端点请求"
// @Success 200 {object} model.APIEndpoint
// @Failure 400 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 404 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/documentation/endpoints/{endpoint_id} [put]
func (h *BaseHandler) UpdateAPIEndpoint(c *gin.Context) {
	_, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	endpointIDStr := c.Param("endpoint_id")
	endpointID, err := strconv.ParseInt(endpointIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid endpoint ID"})
		return
	}

	// TODO: 验证端点是否属于当前用户的服务
	// 这需要通过端点ID查找对应的文档，再查找对应的服务

	var req model.UpdateAPIEndpointRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	endpoint, err := h.apiDocStore.UpdateAPIEndpoint(endpointID, &req)
	if err != nil {
		if err.Error() == "API endpoint not found" {
			c.JSON(http.StatusNotFound, gin.H{"error": "API endpoint not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update API endpoint"})
		return
	}

	c.JSON(http.StatusOK, endpoint)
}

// DeleteAPIEndpoint 删除API端点文档
// @Summary 删除API端点文档
// @Description 删除指定的API端点文档
// @Tags Seller
// @Param endpoint_id path int true "端点ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 404 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/documentation/endpoints/{endpoint_id} [delete]
func (h *BaseHandler) DeleteAPIEndpoint(c *gin.Context) {
	_, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	endpointIDStr := c.Param("endpoint_id")
	endpointID, err := strconv.ParseInt(endpointIDStr, 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid endpoint ID"})
		return
	}

	// TODO: 验证端点是否属于当前用户的服务

	if err := h.apiDocStore.DeleteAPIEndpoint(endpointID); err != nil {
		if err.Error() == "API endpoint not found" {
			c.JSON(http.StatusNotFound, gin.H{"error": "API endpoint not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete API endpoint"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "API endpoint deleted successfully"})
}

// --- 账户设置相关处理函数 (Account Settings Handlers) ---

// GetUserProfile godoc
// @Summary 获取用户个人资料
// @Description 获取当前用户的个人资料信息
// @Tags Account
// @Accept json
// @Produce json
// @Success 200 {object} model.UserProfile
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/profile [get]
func (h *BaseHandler) GetUserProfile(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	profile, err := h.userAccountStore.GetUserProfile(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user profile"})
		return
	}

	c.JSON(http.StatusOK, profile)
}

// UpdateUserProfile godoc
// @Summary 更新用户个人资料
// @Description 更新当前用户的个人资料信息
// @Tags Account
// @Accept json
// @Produce json
// @Param profile body model.UpdateUserProfileRequest true "个人资料信息"
// @Success 200 {object} model.UserProfile
// @Failure 400 {object} model.ErrorResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/profile [put]
func (h *BaseHandler) UpdateUserProfile(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req model.UpdateUserProfileRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	profile, err := h.userAccountStore.UpdateUserProfile(userID.(int64), &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user profile"})
		return
	}

	c.JSON(http.StatusOK, profile)
}

// GetUserSettings godoc
// @Summary 获取用户设置
// @Description 获取当前用户的偏好设置
// @Tags Account
// @Accept json
// @Produce json
// @Success 200 {object} model.UserSettings
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/settings [get]
func (h *BaseHandler) GetUserSettings(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	settings, err := h.userAccountStore.GetUserSettings(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user settings"})
		return
	}

	c.JSON(http.StatusOK, settings)
}

// UpdateUserSettings godoc
// @Summary 更新用户设置
// @Description 更新当前用户的偏好设置
// @Tags Account
// @Accept json
// @Produce json
// @Param settings body model.UpdateUserSettingsRequest true "用户设置信息"
// @Success 200 {object} model.UserSettings
// @Failure 400 {object} model.ErrorResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/settings [put]
func (h *BaseHandler) UpdateUserSettings(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req model.UpdateUserSettingsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	settings, err := h.userAccountStore.UpdateUserSettings(userID.(int64), &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user settings"})
		return
	}

	c.JSON(http.StatusOK, settings)
}

// GetUserSecurity godoc
// @Summary 获取用户安全设置
// @Description 获取当前用户的安全设置信息
// @Tags Account
// @Accept json
// @Produce json
// @Success 200 {object} model.UserSecurity
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/security [get]
func (h *BaseHandler) GetUserSecurity(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	security, err := h.userAccountStore.GetUserSecurity(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user security settings"})
		return
	}

	c.JSON(http.StatusOK, security)
}

// UpdateUserSecurity godoc
// @Summary 更新用户安全设置
// @Description 更新当前用户的安全设置
// @Tags Account
// @Accept json
// @Produce json
// @Param security body model.UpdateUserSecurityRequest true "安全设置信息"
// @Success 200 {object} model.UserSecurity
// @Failure 400 {object} model.ErrorResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/security [put]
func (h *BaseHandler) UpdateUserSecurity(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req model.UpdateUserSecurityRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	security, err := h.userAccountStore.UpdateUserSecurity(userID.(int64), &req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user security settings"})
		return
	}

	c.JSON(http.StatusOK, security)
}

// ChangePassword godoc
// @Summary 修改密码
// @Description 修改当前用户的登录密码
// @Tags Account
// @Accept json
// @Produce json
// @Param password body model.ChangePasswordRequest true "密码修改信息"
// @Success 200 {object} map[string]string
// @Failure 400 {object} model.ErrorResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/change-password [post]
func (h *BaseHandler) ChangePassword(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req model.ChangePasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	// TODO: 这里需要先验证当前密码，然后对新密码进行哈希处理
	// 目前简化处理，直接使用新密码作为哈希值
	err := h.userAccountStore.UpdateUserPassword(userID.(int64), req.NewPassword)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to change password"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

// GetUserAccount godoc
// @Summary 获取完整用户账户信息
// @Description 获取当前用户的完整账户信息，包括个人资料、设置和安全信息
// @Tags Account
// @Accept json
// @Produce json
// @Success 200 {object} model.UserAccountResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/auth/account [get]
func (h *BaseHandler) GetUserAccount(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	account, err := h.userAccountStore.GetCompleteUserAccount(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user account"})
		return
	}

	c.JSON(http.StatusOK, account)
}

// GetSellerAccountSettings godoc
// @Summary 获取卖家专用账户设置
// @Description 获取卖家的专用账户设置信息
// @Tags Seller
// @Accept json
// @Produce json
// @Success 200 {object} model.UserAccountResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/account-settings [get]
func (h *BaseHandler) GetSellerAccountSettings(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	account, err := h.userAccountStore.GetCompleteUserAccount(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get seller account settings"})
		return
	}

	c.JSON(http.StatusOK, account)
}

// UpdateSellerAccountSettings godoc
// @Summary 更新卖家专用账户设置
// @Description 更新卖家的专用账户设置信息
// @Tags Seller
// @Accept json
// @Produce json
// @Param settings body model.UserAccountResponse true "卖家账户设置信息"
// @Success 200 {object} model.UserAccountResponse
// @Failure 400 {object} model.ErrorResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/seller/account-settings [put]
func (h *BaseHandler) UpdateSellerAccountSettings(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req model.UserAccountResponse
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	// 更新个人资料
	if req.Profile != nil {
		profileReq := model.UpdateUserProfileRequest{
			DisplayName: req.Profile.DisplayName,
			AvatarURL:   req.Profile.AvatarURL,
			Bio:         req.Profile.Bio,
			PhoneNumber: req.Profile.PhoneNumber,
			Company:     req.Profile.Company,
			Website:     req.Profile.Website,
			Location:    req.Profile.Location,
			Timezone:    req.Profile.Timezone,
		}
		_, err := h.userAccountStore.UpdateUserProfile(userID.(int64), &profileReq)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile"})
			return
		}
	}

	// 更新用户设置
	if req.Settings != nil {
		settingsReq := model.UpdateUserSettingsRequest{
			Language:           req.Settings.Language,
			EmailNotifications: &req.Settings.EmailNotifications,
			SMSNotifications:   &req.Settings.SMSNotifications,
			MarketingEmails:    &req.Settings.MarketingEmails,
			APIUsageAlerts:     &req.Settings.APIUsageAlerts,
			SecurityAlerts:     &req.Settings.SecurityAlerts,
			Theme:              req.Settings.Theme,
			DateFormat:         req.Settings.DateFormat,
			Currency:           req.Settings.Currency,
		}
		_, err := h.userAccountStore.UpdateUserSettings(userID.(int64), &settingsReq)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update settings"})
			return
		}
	}

	// 更新安全设置
	if req.Security != nil {
		securityReq := model.UpdateUserSecurityRequest{
			TwoFactorEnabled:   &req.Security.TwoFactorEnabled,
			PasswordExpiryDays: &req.Security.PasswordExpiryDays,
			LoginNotifications: &req.Security.LoginNotifications,
			SessionTimeout:     &req.Security.SessionTimeout,
			AllowedIPRanges:    req.Security.AllowedIPRanges,
		}
		_, err := h.userAccountStore.UpdateUserSecurity(userID.(int64), &securityReq)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update security settings"})
			return
		}
	}

	// 返回更新后的完整账户信息
	account, err := h.userAccountStore.GetCompleteUserAccount(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get updated account settings"})
		return
	}

	c.JSON(http.StatusOK, account)
}

// GetBuyerAccountSettings godoc
// @Summary 获取买家专用账户设置
// @Description 获取买家的专用账户设置信息
// @Tags Buyer
// @Accept json
// @Produce json
// @Success 200 {object} model.UserAccountResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/buyer/account-settings [get]
func (h *BaseHandler) GetBuyerAccountSettings(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	account, err := h.userAccountStore.GetCompleteUserAccount(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get buyer account settings"})
		return
	}

	c.JSON(http.StatusOK, account)
}

// UpdateBuyerAccountSettings godoc
// @Summary 更新买家专用账户设置
// @Description 更新买家的专用账户设置信息
// @Tags Buyer
// @Accept json
// @Produce json
// @Param settings body model.UserAccountResponse true "买家账户设置信息"
// @Success 200 {object} model.UserAccountResponse
// @Failure 400 {object} model.ErrorResponse
// @Failure 401 {object} model.ErrorResponse
// @Failure 403 {object} model.ErrorResponse
// @Failure 500 {object} model.ErrorResponse
// @Router /api/v1/buyer/account-settings [put]
func (h *BaseHandler) UpdateBuyerAccountSettings(c *gin.Context) {
	userID, exists := c.Get("user_id")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
		return
	}

	var req model.UserAccountResponse
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	// 更新个人资料
	if req.Profile != nil {
		profileReq := model.UpdateUserProfileRequest{
			DisplayName: req.Profile.DisplayName,
			AvatarURL:   req.Profile.AvatarURL,
			Bio:         req.Profile.Bio,
			PhoneNumber: req.Profile.PhoneNumber,
			Company:     req.Profile.Company,
			Website:     req.Profile.Website,
			Location:    req.Profile.Location,
			Timezone:    req.Profile.Timezone,
		}
		_, err := h.userAccountStore.UpdateUserProfile(userID.(int64), &profileReq)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile"})
			return
		}
	}

	// 更新用户设置
	if req.Settings != nil {
		settingsReq := model.UpdateUserSettingsRequest{
			Language:           req.Settings.Language,
			EmailNotifications: &req.Settings.EmailNotifications,
			SMSNotifications:   &req.Settings.SMSNotifications,
			MarketingEmails:    &req.Settings.MarketingEmails,
			APIUsageAlerts:     &req.Settings.APIUsageAlerts,
			SecurityAlerts:     &req.Settings.SecurityAlerts,
			Theme:              req.Settings.Theme,
			DateFormat:         req.Settings.DateFormat,
			Currency:           req.Settings.Currency,
		}
		_, err := h.userAccountStore.UpdateUserSettings(userID.(int64), &settingsReq)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update settings"})
			return
		}
	}

	// 更新安全设置
	if req.Security != nil {
		securityReq := model.UpdateUserSecurityRequest{
			TwoFactorEnabled:   &req.Security.TwoFactorEnabled,
			PasswordExpiryDays: &req.Security.PasswordExpiryDays,
			LoginNotifications: &req.Security.LoginNotifications,
			SessionTimeout:     &req.Security.SessionTimeout,
			AllowedIPRanges:    req.Security.AllowedIPRanges,
		}
		_, err := h.userAccountStore.UpdateUserSecurity(userID.(int64), &securityReq)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update security settings"})
			return
		}
	}

	// 返回更新后的完整账户信息
	account, err := h.userAccountStore.GetCompleteUserAccount(userID.(int64))
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get updated account settings"})
		return
	}

	c.JSON(http.StatusOK, account)
}

// smartPathJoin 智能合并两个路径，避免重复路径段
// 例如: smartPathJoin("/v1", "v1/chat/completions") -> "/v1/chat/completions"
//      smartPathJoin("/", "v1/chat/completions") -> "/v1/chat/completions"
//      smartPathJoin("/api", "v1/chat/completions") -> "/api/v1/chat/completions"
func smartPathJoin(basePath, sellerPath string) string {
	// 清理路径
	basePath = path.Clean(basePath)
	sellerPath = strings.TrimPrefix(sellerPath, "/")
	
	// 如果基础路径是根路径，直接返回卖家路径
	if basePath == "/" || basePath == "." {
		return "/" + sellerPath
	}
	
	// 分割路径段
	baseSegments := strings.Split(strings.Trim(basePath, "/"), "/")
	sellerSegments := strings.Split(sellerPath, "/")
	
	// 如果卖家路径为空，返回基础路径
	if len(sellerSegments) == 1 && sellerSegments[0] == "" {
		return basePath
	}
	
	// 检查是否有重复的路径段
	if len(baseSegments) > 0 && len(sellerSegments) > 0 {
		// 如果基础路径的最后一段与卖家路径的第一段相同，跳过重复
		if baseSegments[len(baseSegments)-1] == sellerSegments[0] {
			sellerSegments = sellerSegments[1:]
		}
	}
	
	// 合并路径段
	allSegments := append(baseSegments, sellerSegments...)
	
	// 过滤空段
	var filteredSegments []string
	for _, segment := range allSegments {
		if segment != "" {
			filteredSegments = append(filteredSegments, segment)
		}
	}
	
	// 构建最终路径
	if len(filteredSegments) == 0 {
		return "/"
	}
	
	return "/" + strings.Join(filteredSegments, "/")
}

// TODO: 将上述占位符 handler 替换为具体的实现，并可能拆分到不同的文件中，
// 例如 auth_handler.go, seller_handler.go, buyer_handler.go, proxy_handler.go, usage_handler.go。
// 每个具体的 handler 将接收其所需的依赖 (如特定的 store 实例, JWT 密钥, 加密密钥等)。